<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nix-Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="ch00-00-the-nix-package-manager.html">The Nix Package Manager</a></li><li class="chapter-item expanded affix "><a href="ch01-00-preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="ch02-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch03-00-installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch04-00-derivations.html"><strong aria-hidden="true">2.</strong> Derivations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-create-a-derivation.html"><strong aria-hidden="true">2.1.</strong> Create a Derivation</a></li><li class="chapter-item expanded "><a href="ch04-02-realise-a-derivation.html"><strong aria-hidden="true">2.2.</strong> Realise a Derivation</a></li><li class="chapter-item expanded "><a href="ch04-03-using-derivations-from-nix.html"><strong aria-hidden="true">2.3.</strong> Using Derivations from Nix</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-the-nix-language.html"><strong aria-hidden="true">3.</strong> The Nix Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-language-basics.html"><strong aria-hidden="true">3.1.</strong> Language Basics</a></li><li class="chapter-item expanded "><a href="ch05-02-functions.html"><strong aria-hidden="true">3.2.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch05-03-imports-and-callpackage.html"><strong aria-hidden="true">3.3.</strong> Imports and callPackage</a></li><li class="chapter-item expanded "><a href="ch05-04-best-practices.html"><strong aria-hidden="true">3.4.</strong> Best Practices</a></li><li class="chapter-item expanded "><a href="ch05-05-common-mistakes.html"><strong aria-hidden="true">3.5.</strong> Common Mistakes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-building-a-nix-package.html"><strong aria-hidden="true">4.</strong> Building a Nix Package</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-simple-c-program.html"><strong aria-hidden="true">4.1.</strong> Simple C program</a></li><li class="chapter-item expanded "><a href="ch06-02-stdenv.html"><strong aria-hidden="true">4.2.</strong> Stdenv</a></li><li class="chapter-item expanded "><a href="ch06-03-phases.html"><strong aria-hidden="true">4.3.</strong> Phases</a></li><li class="chapter-item expanded "><a href="ch06-04-build-dependencies.html"><strong aria-hidden="true">4.4.</strong> Build Dependencies</a></li><li class="chapter-item expanded "><a href="ch06-05-runtime-dependencies.html"><strong aria-hidden="true">4.5.</strong> Runtime Dependencies</a></li><li class="chapter-item expanded "><a href="ch06-06-building-packages-for-other-toolchains.html"><strong aria-hidden="true">4.6.</strong> Building Packages for Other Toolchains</a></li><li class="chapter-item expanded "><a href="ch06-07-building-packages-for-other-languages.html"><strong aria-hidden="true">4.7.</strong> Building Packages for Other Languages</a></li><li class="chapter-item expanded "><a href="ch06-08-patching.html"><strong aria-hidden="true">4.8.</strong> Patching</a></li><li class="chapter-item expanded "><a href="ch06-09-multiple-outputs.html"><strong aria-hidden="true">4.9.</strong> Multiple Outputs</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Nix-Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-nix-package-manager"><a class="header" href="#the-nix-package-manager">The Nix Package Manager</a></h1>
<p><em>by Jonathan Ringer and Tim Deherra</em></p>
<p>This book assumes usage of the nix 3.0 cli. Which can be enabled in nix 2.4+
<a href="https://nixos.wiki/wiki/Flakes#Enable_flakes">following these instructions</a>.</p>
<p>This book is available on the web at <a href="https://book.divnix.com/">https://book.divnix.com/</a>.
For changes to the book, please see the <a href="https://github.com/divnix/nix-book">https://github.com/divnix/nix-book</a>.</p>
<h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>My journey to learn nix was only possible by my extreme desire to master it.
The path was anything but easy and predictable. And it is still a considerable
hurdle for many trying to learn nix.</p>
<p>The goal of this book is to provide newcomers with a more approachable
document than the <a href="https://nixos.org/guides/nix-pills">nix-pills series</a>.
Although nix-pills is still a very good resource
with many years of refinement, it is extensive and hard to follow without
some prior knowledge of nix. This book hopes to 
provide a more recent account of nix with more of a focus on giving the user
intuition around what nix is doing rather than a deep understanding like nix-pills.</p>
<p>The goal is not to replace any existing nix guides or documentation, but rather
provide a good starting place for new users. Motivation for writing
this is to provide a &quot;nix equilavent of the <a href="https://doc.rust-lang.org/book/">rust-lang book</a>&quot;.
Where there is one resource which can be read end-to-end in an afternoon and
able to equip the reader with the knowledge necessary
to thrive in the nix ecosystem.</p>
<p>-- Jonathan Ringer</p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h1 id="the-nix-package-manager-1"><a class="header" href="#the-nix-package-manager-1">The Nix Package Manager</a></h1>
<p>Nix is a package manager which focuses on
caputuring all inputs which contribute to building software.
The result of factoring all of the information about building
the software is called a derivation. This aggregated information includes where
the source code is pulled, configuration flags, patches,
dependencies, build steps, installation steps, and many other potential inputs.</p>
<p>This information is aggregated through hashing, and allows nix to
describe and reference the exact software which is intended to use.
This enables nix to be used on any system because it's assumptions
do not collide with the assumptions of a host system. This also means that
nix does not adhere to the traditional <a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">File Hierarchical System(FHS)</a>
but it also means that it's not limited to FHS's restriction of only having
a single variant of a piece of software.</p>
<h1 id="who-is-nix-for"><a class="header" href="#who-is-nix-for">Who is Nix For</a></h1>
<h2 id="teams-of-developers"><a class="header" href="#teams-of-developers">Teams of Developers</a></h2>
<p>Development needs to have similar tooling across every individual. Having divergent
development environments and productions environments is a major cause of regressions
in software development. Nix can help mitigate this by allowing development environments
to be version controlled and maintained along with a project.</p>
<h2 id="devops-operations"><a class="header" href="#devops-operations">DevOps (Operations)</a></h2>
<p>Nix allows you to percisely describe the software you intended to use. Nix packages
are defined by their dependencies, so they inherently retain their SBOM (Software Bill of Materials)
by default. By leveraging NixOS modules, one can also create configurable services and compose
it into coherent systems. The combination of Nix + NixOS allows you to have delcarative configuration
of both services and sytems.</p>
<h2 id="system-administrators-home-to-enterprise"><a class="header" href="#system-administrators-home-to-enterprise">System Administrators (home to enterprise)</a></h2>
<p>Ever have to maintain a few systems to a few hundred systems? The ability to version control and manipulate
systems-as-code enables a new paradigm of system configuration management. Atomically apply or rollback
system updates for each system. Nixpkgs can also be freely extended to include personal or private additions
of software; this allows you to leverage all other Nix tooling as though your application-specific software
was a first-class citizen.</p>
<p>Also, Nix largely invalidates the need for docker. However, nix can also be used to produce docker images
if there is a downstream technology which consumes oci images as an interface (E.g. kubernetes).</p>
<h2 id="power-users"><a class="header" href="#power-users">Power Users</a></h2>
<p>Do you have incredible specific or opinated environments? Nix allows you to declaratively create
project (flakes), user (home-manager), or system (NixOS) environments with the exact software
and configuration you desired. Whether you're building software or ricing a desktop, nix will allow
you to version control and specify your configuration exactly how you intended.</p>
<h1 id="the-nix-ecosystem"><a class="header" href="#the-nix-ecosystem">The Nix Ecosystem</a></h1>
<p>There's roughly four layers of abstractions in the official nix ecosystem, these are:</p>
<ul>
<li>Nix - The domain-specifc language used to write nix expressions</li>
<li>Nix - The package manager</li>
<li>Nixpkgs - The official Nix package repository</li>
<li>NixOS - A linux distribution built upon nixpkgs</li>
</ul>
<p>There are also a few unofficial projects which are commonly used within the community:</p>
<ul>
<li><a href="https://github.com/nix-community/home-manager">Home-manager</a> - NixOS-like user configuration for linux or MacOS built upon nixpkgs</li>
<li><a href="https://github.com/LnL7/nix-darwin">Nix-darwin</a> - NixOS-like configuration, but for MacOS</li>
</ul>
<p>All of these topics will be discussed in greater detail in later sections, but a 
quick summary of official projects are provided below.</p>
<h2 id="the-nix-language"><a class="header" href="#the-nix-language">The Nix Language</a></h2>
<p>The Nix language is a Domain-Specific Language (DSL) which is designed to
handle package configuration. Nix can be thought of <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> + functions +
some syntax sugar. It's main goal is to provide effect-free evaluation of
package configuration, to this point Nix is restricted in many ways and lacks
many features from generic programming languages. There is very limited input and
output possible to the system, there are no loops, no concurrency primitives, and
no types. What is left is a small functional-oriented programming language. After all,
Nix's goal is to take a few inputs such as a system platform, and produce a build
graph which can be used to build software.</p>
<h2 id="nix-the-package-manager"><a class="header" href="#nix-the-package-manager">Nix the Package Manager</a></h2>
<p>The Nix Package Manager began its life as the <a href="https://edolstra.github.io/pubs/phd-thesis.pdf">PhD thesis work</a>
of Eelco Dolstra. The goal was to bring discipline to the software landscape. Similar to
how structured programming helped tame the complexity of goto through introducing constructs such
as loops and logic flow; so too does nix attempt to tame the chaos of package management
through explicit descriptions of software and their dependencies. The truely novel idea
of Nix is that of the <em>derivation</em>. It encapsulates everything about a piece of software,
and these derivations can be referenced from other derivations constituting a Directed-Acyclic-Graph
of how to built that software from source.</p>
<h2 id="nixpkgs"><a class="header" href="#nixpkgs">Nixpkgs</a></h2>
<p>Nixpkgs is the official package repository for the Nix community. It contains the logic
on how to build over 60,000+ software packages. Nixpkgs can be thought of as an
expert body-of-knowledge on the subject of how to build software. When a user
asks for the &quot;firefox&quot; package, the nix package manager is able to input the user's computer
platform into nixpkgs, and nixpkgs is then able to produce a build graph on
how to build firefox and all of it's dependencies down to the C compiler.
This allows for a great deal of freedom in how nix is leveraged, and nix can be used on any Linux distribution and MacOS as
first class supported OS's, and to a much lesser degree on many other UNIX-like OS's.</p>
<h2 id="nixos"><a class="header" href="#nixos">NixOS</a></h2>
<p>NixOS is a non-FHS Linux distribution which leverages nixpkgs to provide a wealth
of software ready to be combined into a system environment. The concept of a nix
derivation is extended here to include service configuration and system creation.
The entirity of the system is represented as a derivation which gives it many of
it's defining qualities such as atomic rollbacks, system-as-a-configuration-file,
extensive user configuration potential.</p>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="linux-and-macos"><a class="header" href="#linux-and-macos">Linux and MacOS</a></h2>
<p>The guided installer is the preferred way to install nix, please run the following in a shell:</p>
<pre><code>sh &lt;(curl -L https://nixos.org/nix/install) --daemon
</code></pre>
<h2 id="other-installation-methods"><a class="header" href="#other-installation-methods">Other Installation Methods</a></h2>
<p>There are many ways to leverage nix, for more installation options, please visit
the <a href="https://nixos.org/download.html">official download page</a>.</p>
<h1 id="derivations"><a class="header" href="#derivations">Derivations</a></h1>
<p>Derivations are the defining feature of nix. Derivations attempt to capture everything
that it would take to build a package. This includes, but is not limited to: source code,
dependencies, build flags, build and installation steps, tests, and environment variables.
The culmination of all direct and transitive build depdencies
is commonly refered to as the derivations's &quot;build closure&quot;. More dependencies that a
package refers to, more package will need to be created in order to attempt a
build. Generally, dependencies of a derivation are other derivations.</p>
<h2 id="types-of-derivations"><a class="header" href="#types-of-derivations">Types of Derivations</a></h2>
<h3 id="fixed-output-derivations-fods"><a class="header" href="#fixed-output-derivations-fods">Fixed Output Derivations (FODs)</a></h3>
<p>These are the &quot;leaves&quot; of any build closure, in that, they do not refer to other
derivations. These derivations are defined by
their content. These derivations are easily differientiated because they
will contain a sha256 (or other hash) which is used to enforce that an artifact
is reproducible.</p>
<p>One critical difference from evaluated derivations is that Fixed-Output derivations
are able to have access to the network while fetching contents. This &quot;impurity&quot;
is offset by enforcing that the hash matches, and reproducibility is delegated to
the process which fetchs the assets.</p>
<p>Many of the <code>fetch*</code> utilities in nixpkgs and nix's builtins will create FODs.</p>
<h3 id="input-addressed-derivations"><a class="header" href="#input-addressed-derivations">Input-Addressed Derivations</a></h3>
<p>Input-Addressed derivations are generally what are referred to when the term derivation is used. These
derivations are defined by all of the dependencies, build phases, and flags
present during a build. Nix captures all of the variables which constitute a
derivation and uses a cryptographic hash to give each derivation a unique name.</p>
<p><code>stdenv.mkDerivation</code> and related <code>build*</code> helpers will create an input-addressed derivation.</p>
<h3 id="content-addressable-derivations-ca-derivations"><a class="header" href="#content-addressable-derivations-ca-derivations">Content-Addressable Derivations (CA Derivations)</a></h3>
<p><strong>NOTE</strong>: CA Derivations are still considered experimental at the time of writing</p>
<p>Content-Addressable (CA) derivations are a hybrid of both FOD and IA derivations.
The problem which CA derivations address are rebuilds. In the IA derivation model, a patch
to openssl will cause all downstream packages to rebuild since that derivation will
propagate the patch change across all consumers. Under CA derivations, nix can determine
that a consuming package which was built before the openssl patch has remained unchanged
with the only exception being where openssl is located in the nix store. In this case
the package which uses openssl is &quot;the same&quot; in usage, the only thing which has changed is what
variant of openssl it uses. Nix is then free to assert an equivalence of the
package before and after the openssl patch; thus, it doesn't need to rebuild all packages,
just update the references of openssl.</p>
<p>The name Content-Addressable comes from the fact that the implementation will stub out nix store
paths and use this normalized content to compare against other builds. Now nix can deduplicate
builds which were done previously. In the openssl example, the build of curl will likely be
exactly the same; thus any package which just consumes curl will not have to be rebuilt. Only
the references to the new variant of curl needs to be updated.</p>
<p>CA derivations are an opt-in experimental feature, but don't require the user to alter their
existing workflows.</p>
<h1 id="create-a-derivation"><a class="header" href="#create-a-derivation">Create a Derivation</a></h1>
<p>Before a package is built, a derivation must be created. The derivation can
be thought of as the unamiguous definition of how to build a package.
The process of creating a derivation  is called &quot;instantiatiation&quot;,
or sometimes also refered to as evaluation (although this is more general). Every package in
nixpkgs has a corresponding derivation. This means that we can
create and inspect the derivation for anything exposed in nixpkgs. An example
would be:</p>
<pre><code>$ nix-instantiate '&lt;nixpkgs&gt;' -A hello
/nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv

# or using flakes, nix&gt;=2.4

$ nix eval nixpkgs#hello.drvPath
&quot;/nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv&quot;
</code></pre>
<h2 id="inspect-the-contents-of-a-derivation"><a class="header" href="#inspect-the-contents-of-a-derivation">Inspect the contents of a derivation</a></h2>
<p>To inspect the contents of the drv, one can use the <code>nix show-derivation</code> utility.</p>
<pre><code>$ nix show-derivation /nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv
{
  &quot;/nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv&quot;: {
    &quot;outputs&quot;: {
      &quot;out&quot;: {
        &quot;path&quot;: &quot;/nix/store/f4bywv8hjwl0ckv7l077pnap81h6qxw4-hello-2.10&quot;
      }
...
</code></pre>
<h2 id="defining-characteristics-of-a-derivation"><a class="header" href="#defining-characteristics-of-a-derivation">Defining characteristics of a derivation</a></h2>
<p>There's a few important features of a derivation:</p>
<ul>
<li>It's a description of how to build the package from source</li>
<li>The output paths are determined before the build begins</li>
<li>All dependencies are resolved as part of instantiation, and may have a similar derivation description of their builds</li>
<li>Any additional flags (makeFlags, configuration flags, cflags, or ld flags) are explicitly stated</li>
<li>There's no ambiguity. The system, architecture, and other options have been resolved.</li>
<li>It's immutable. If you want to change a derivation, you need to evaluate a new one.</li>
<li>It's unique. The hashing scheme ensures that there should only ever be one derivation; if two derivations match, then they are exactly the same in every way.</li>
</ul>
<h1 id="realise-a-derivation"><a class="header" href="#realise-a-derivation">Realise a derivation</a></h1>
<p>Building a derivation is referred to as &quot;realisation&quot;. A derivation is just an abstract
description of a package, based upon what it requires to build. Derivations can be thought
of as constructing a blueprint, but realisation is the construction of the desired object.
Taking from the previous example, one can build a derivations like so:</p>
<pre><code>$ nix-store --realise /nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv
...
/nix/store/f4bywv8hjwl0ckv7l077pnap81h6qxw4-hello-2.10

# or in nix flakes:

$ nix build nixpkgs#hello
...
/nix/store/f4bywv8hjwl0ckv7l077pnap81h6qxw4-hello-2.10
</code></pre>
<p>Here, the gnu hello project was built and installed at the output path. This
includes: the executable binary, documenation, and locale info.</p>
<pre><code>$ tree -L 2 /nix/store/f4bywv8hjwl0ckv7l077pnap81h6qxw4-hello-2.10
/nix/store/f4bywv8hjwl0ckv7l077pnap81h6qxw4-hello-2.10
├── bin
│   └── hello
└── share
    ├── info
    ├── locale
    └── man
</code></pre>
<p>The <code>nix-build</code> and <code>nix build</code> commands will perform both instantiation and realisation. 
These are the most common commands used when iterating on packages. One could also do:</p>
<pre><code>$ nix-buid '&lt;nixpkgs&gt;' -A hello
# these are the same, nix build is just much more concise
$ nix-store --realise $(nix-instantiate '&lt;nixpkgs&gt;' -A hello)
</code></pre>
<p><em>Note:</em> Many other commands also will realise a derivation
as part of a workflow. Some examples are:
<code>nix-shell</code>, <code>nix shell</code>, <code>nix-env</code>, <code>nix run</code>, and <code>nix profile</code>.
These commands are very goal oriented and will differ
significantly in how they leverage nix, often realisation
is an side-effect to achieve that goal.</p>
<h1 id="using-derivations-from-nix"><a class="header" href="#using-derivations-from-nix">Using Derivations from Nix</a></h1>
<p>The derivation is the main abstraction of nix. All of
Nixpkgs and NixOS is created by leveraging derivations
to create new derivations, scripts, services, and even
entire linux distributions. The ability to compose these
usecases with uniquely named packages allows nix the
freedom to aggressively share common dependencies, meanwhile
allowing the flexibility to have potentially incompatible
packages available on the system.</p>
<p>The nix language allows for consumption of derivations
to be quite transparent. For example:</p>
<pre><code>$ cat hello.nix
let
  pkgs = import &lt;nixpkgs&gt; { };
in
  pkgs.writeScriptBin &quot;greet.sh&quot; ''
    ${pkgs.hello}/bin/hello -g &quot;Hello $USER!&quot;
  ''

$ nix-build hello.nix
this derivation will be built:
  /nix/store/xd9qpwnvybm9p8k2szhkvpd2ym85is9p-greet.sh.drv
building '/nix/store/xd9qpwnvybm9p8k2szhkvpd2ym85is9p-greet.sh.drv'...
/nix/store/h8yxaciazc8basn9l335bmdrpfak0aqk-greet.sh

$ cat ./result/bin/greet.sh
/nix/store/mg35qkhk7wqbhhykpakds4fsm1riy8ga-hello-2.12.1/bin/hello -g &quot;Hello $USER!&quot;

$ ./result/bin/greet.sh
Hello jon!
</code></pre>
<p>We created a <code>greet.sh</code> script which will greet the user.
Nix first created the &quot;derivation&quot; (build plan) of our script at
<code>/nix/store/&lt;hash&gt;-greet.sh.drv</code>, and then realised (built) the derivation as
<code>/nix/store/&lt;hash&gt;-greet.sh</code>.
We can see from the contents of the resulting file that
<code>pkgs.hello</code> was substituted for the realised output path.
This allows for us to not worry about what the unique name
of the derivation will be, but rather worry about the 
contents post realisation.</p>
<p>Although this may not seem markedly better than other package
management workflows such as: please install these tools, then run
this script. There is quite a lot of benefit to leveraging nix whether
it's to create scripts or build more software:</p>
<ul>
<li>Use of exact versions which you control
<ul>
<li>For example, which version of python or node do you have?</li>
</ul>
</li>
<li>No longer dependent on the state of the consuming system
<ul>
<li>For example, do you have python installed?</li>
</ul>
</li>
<li>Use of multiple versions of the same software
<ul>
<li>Want to use NodeJS v14 in one script, but NodeJS v16 in another? No problem.</li>
</ul>
</li>
</ul>
<p>Although many ecosystems will have ecosystem specific solutions to these solutions
(e.g. tox for python, nvm for node), nix provides a universal abstraction for
native dependencies and any downstream dependencies.</p>
<h3 id="use-of-outpath-as-a-tostring"><a class="header" href="#use-of-outpath-as-a-tostring">Use of &quot;outPath&quot; as a toString</a></h3>
<p>This is one of the oddities of nix, but stringification of
an object which contains a key &quot;outPath&quot; will return
the contents of the &quot;outPath&quot; key. Since all derivations
will have an outPath, any usage of them in a string
will yeild the store path that they create.</p>
<pre><code class="language-nix">nix-repl&gt; a = { outPath = &quot;foo&quot;; }

nix-repl&gt; &quot;${a} bar&quot;
&quot;foo bar&quot;
</code></pre>
<h1 id="the-nix-language-1"><a class="header" href="#the-nix-language-1">The Nix Language</a></h1>
<p>Nix is a pure, lazy, functional language which serves a domain-specific language (DSL)
for writing nix derivations and expressions. In general, nix can be thought of as 
JSON with functions. </p>
<p>The goal of Nix is to facilitate the creation of a derivation. In most situations
nix is given a small amount input and expected to produce a result (usually a derivation).
In the case of nixpkgs, the workflow is generally, &quot;given the user has an x86_64-linux
device and the information held within nixpkgs then the desired package will be
<code>/nix/store/&lt;some hash&gt;-&lt;package&gt;</code>. This is also why the word evaluation is used commonly
when refering to nix packages, the nix expression which describes how to build
software can evaluate to it's final reduced state given just a system platform.</p>
<h1 id="nix-language-basics"><a class="header" href="#nix-language-basics">Nix Language Basics</a></h1>
<h2 id="primitive-values"><a class="header" href="#primitive-values">Primitive Values</a></h2>
<p>These values are mostly similar to JSON:</p>
<table><thead><tr><th>Type</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td>integer</td><td>Whole number</td><td>1</td></tr>
<tr><td>float</td><td>Floating point number</td><td>1.054</td></tr>
<tr><td>string</td><td>UTF-8 string</td><td>&quot;hello!&quot;</td></tr>
<tr><td>path</td><td>File or url</td><td>./default.nix</td></tr>
</tbody></table>
<p><em>NOTE</em>: Paths are special. They will be resolved relative to the file.
The value must contain a &quot;/&quot; to be considered a path, however, 
it's common to construct the value starting with &quot;.&quot; to avoid confusion
(e.g. ./foo/bar vs foo/bar).
If a path is referenced as part of a package, that path will be added to the
nix store, and all references to that path will be substituted with the nix store path.</p>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>Nix exposes two ways to express strings. Strings are enclosed with double quotes: <code>&quot;hello&quot;</code>.
This works well for small strings, such as simple flags. However, it's common to write a
block of commands which need to be executed; for this, nix also has multi-line support with
the &quot;lines&quot; construct. &quot;lines&quot; are denoted by two single quotes.</p>
<p>Example usage of lines:</p>
<pre><code>  postPatch = ''
    ./autogen.sh
    mkdir build
    cd build
  '';
</code></pre>
<p>Here, we have postPatch being assigned a series of commands to be ran as part of a build.</p>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<p>Lists work similarly to most other languages, but are whitespace delimited. <code>[ 1 2 ]</code> is an
array with elements <code>1</code> and <code>2</code>.</p>
<p><strong>Note</strong>: For oddities around lists and elements which use whitespace, please see <a href="./ch05-05-common-mistakes.html#lists">list common mistakes</a>.</p>
<h2 id="attribute-set-attr-set"><a class="header" href="#attribute-set-attr-set">Attribute Set (Attr set)</a></h2>
<p>This can be thought of as a dictionary or map in most other languages. The important distinct is that the
keys are always ordered, so that the order doesn't influence how a derivation will produce a hash. Attr sets
values do not need to be of the same type. Attr sets are constructed using an <code>=</code> sign which denotes key value
pairs which are separated with semicolons <code>;</code>, the attr set is enclosed with curly braces <code>{ }</code>. Selection
of an attribute is done through dot-notation <code>&lt;set&gt;.&lt;key&gt;</code>.</p>
<pre><code>nix-repl&gt; a = { foo = &quot;bar&quot;; count = 5; flags = ''-g -O3''; }
nix-repl&gt; a.count
5

# Shorthand for nested attribute sets
nix-repl&gt; :p { foo.bar.baz = 1; foo.bar.buzz = 2; }
{ foo = { bar = { baz = 1; buzz = 2; }; }; }
</code></pre>
<p>You will commonly see empty attr sets in nixpkgs, an example being:</p>
<pre><code>  hello = callPackage ../applications/misc/hello { };
</code></pre>
<h2 id="derivations-1"><a class="header" href="#derivations-1">Derivations</a></h2>
<p>Technically, a derivation is just an attr set which has a few special attributes
set to valid values which then nix can later realise into a build. Promotion
from an attr set to derivation is facilitated through the <code>builtins.derivation</code>
function. However directly calling the builtin is highly discouraged within
nixpkgs. Instead people are encouraged to use stdenv.mkDerivation and other
established builders which provide many good defaults to achieve their packaging goals.</p>
<h2 id="if--else-logic"><a class="header" href="#if--else-logic">If / Else logic</a></h2>
<p>Like many other functional programming languages, you cannot
use <code>if</code> without an accompanying <code>else</code> clause. This is because
the expression needs to return a value, not just follow a code
path.</p>
<pre><code>  extension = if stdenv.isDarwin then
      &quot;.dylib&quot;
    else
      &quot;.so&quot;;
</code></pre>
<p><strong>Note</strong>: The proper way to find the shared library extension
within nixpkgs is <code>hostPlatform.extensions.sharedLibrary</code>.</p>
<h2 id="let-expressions"><a class="header" href="#let-expressions">Let expressions</a></h2>
<p>Let expressions are a way to define values to be used later in a given 'in' scope.
Generally these are used to alter a given value to conform to a
slightly different format. Let expressions can refer
to other values defined in the same let scope. For haskell users,
let expressions work similarly to how they work in Haskell.</p>
<pre><code>  src = let
    # e.g. 3.1-2 -&gt; 3_1_2
    srcVersion = lib.strings.replaceStrings [ &quot;.&quot; &quot;-&quot; ] [ &quot;_&quot; &quot;_&quot;] version;
    srcUrl = &quot;https://example.com/download/${pname}-${srcVersion}.tar.gz&quot;;
  in fetchurl {
    url = srcUrl;
    sha256 = &quot;...&quot;;
  };
</code></pre>
<h2 id="with-expressions"><a class="header" href="#with-expressions">With expressions</a></h2>
<p>With expressions allows for many values on an attr set to be
exposed by their key names.</p>
<pre><code>  # before
  meta = {
    licenses = lib.licenses.cc0;
    maintainers = [ lib.maintainers.jane lib.maintainers.joe ];
    platforms = lib.platforms.unix;
  };
</code></pre>
<pre><code>  # after
  meta = with lib; {
    licenses = licenses.cc0;
    maintainers = with maintainers; [ jane joe ];
    platforms = platforms.unix;
  };
</code></pre>
<h2 id="laziness"><a class="header" href="#laziness">Laziness</a></h2>
<p>Many pure functional programming languages also have the feature that the
evaluation model of the language is lazy. This means that the values
of a data structure aren't computed until needed.
The benefits for nix is that evaluating a package doesn't mean computing
all packages, but only computing the dependency graph for the packages
requested. In practice this means limiting the scope of an action from
80,000+ possible dependencies to just the dependencies explicitly mentioned
by the nix expressions.</p>
<p>Although laziness isn't a hard requirement for nix to work. The purity
model of nix makes laziness more a symptom rather than an explicit design goal.
However, It does enable many implicit benefits such as <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>.</p>
<h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Nix only has unary functions: unary functions are functions which
only accept one parameter. However, in combination with
<a href="https://en.wikipedia.org/wiki/currying">uncurrying</a>, you can
create functions which take an arbitrary number of parameters.</p>
<p>Functions can be treated as values, and freely passed to other
functions as such. To name a function, it just needs to be assigned
to variable, much as you would do to a literal.</p>
<p>Function examples:</p>
<pre><code># creation, and immediate application of a nameless function
nix-repl&gt; (x: x + 2) 3
5

# assigning a function to a variable, then later applying it
nix-repl&gt; addTwo = x: x + 2

nix-repl&gt; addTwo 3
5

# two parameters
nix-repl&gt; sumBoth = x: y: x + y

nix-repl&gt; sumBoth 2 5
7
</code></pre>
<h2 id="attr-sets-as-inputs"><a class="header" href="#attr-sets-as-inputs">Attr sets as inputs</a></h2>
<p>Nix also heavily uses attr sets to pass around many arguments.
In nixpkgs, this is most commonly used to express what subset of
packages and utilities should be used for a nix expression. It's
also useful when a large context for a function is needed, and
an ordered list of parameters is a poor fit.</p>
<p>Attr sets as inputs are also particular good when the function
can provide good defaults, and only a small subset of inputs are
expected to be edited.</p>
<p>Function examples:</p>
<pre><code class="language-nix"># function which takes an attr set
nix-repl&gt; addTwo = { x }: x + 2

nix-repl&gt; addTwo { x = 3; }
5

# function which takes optional attr set values
nix-repl&gt; addTwoOptional = { x ? 4 }: x + 2

nix-repl&gt; addTwoOptional { }
6

nix-repl&gt; addTwoOptional { x = 5; }
7

# same as above, but binding the entire attr set to another variable
nix-repl&gt; addTwoOptional = { x ? 4 }@args: args.x + 2

nix-repl&gt; addTwoOptional  { x = 6; }
8
</code></pre>
<p><strong>Note</strong>: The <code>@</code> syntax is not very common for most nix expressions.
Its most common use case are &quot;helpers&quot;, which only care about a
subset of arguments, and will then call another function with some
of the inputs pruned. A good example of this is the <code>pkgs.fetchFromGithub</code>
fetcher; which will know how to translate owner, repo, rev, and
other options into a call to <code>builtsin.fetchzip</code> or <code>builtins.fetchgit</code>.</p>
<h1 id="imports-and-callpackage"><a class="header" href="#imports-and-callpackage">Imports and callPackage</a></h1>
<h2 id="import"><a class="header" href="#import">Import</a></h2>
<p><code>import</code> is one of the few keywords in nix. It allows for a file to be read and evaluated. If a directory is passed to <code>import</code>,
then it will assume <code>&lt;directory&gt;/default.nix</code> was the desired file.</p>
<pre><code>$ cat data.nix
{ a = &quot;foo&quot;; b = &quot;bar&quot;; }

nix-repl&gt; :p import ./data.nix
{ a = &quot;foo&quot;; b = &quot;bar&quot;; }

$ cat expression.nix
5+2

nix-repl&gt; :p import ./expression.nix
7
</code></pre>
<p>This still extends to functions:</p>
<pre><code>$ cat function.nix
{ x, y }: x + y

nix-repl&gt; :p import ./function.nix { x = 2; y = 9; }
11
</code></pre>
<h3 id="imports-for-packages"><a class="header" href="#imports-for-packages">Imports for packages</a></h3>
<p>In nixpkgs, each package usually has a corresponding
file associated with the packaging and related concerns of just that package.
Early in nix's history, <code>import</code> was used to integrate the files with other expressions and allow for greater organization of code.
However, the import model is quite explicit, and requires users
to declare the dependencies twice.</p>
<p>Below is an example expression for <code>openssl</code>:</p>
<pre><code># pkgs/libraries/openssl/default.nix
{ lib, stdenv, fetchurl, perl }:

stdenv.mkDerivation {
  ...
}
</code></pre>
<p>In the <code>import</code> paradigm, the calling site would look:</p>
<pre><code>  openssl = import ../libraries/openssl {
    inherit lib stdenv fetchurl perl;
  };
</code></pre>
<p>Obviously this isn't ideal. The dependencies need to be referred to
three times, once at the call site, as inputs to the expression,
and then within the expression at the appropriate section.
The tediousness of passing the values will be solved by <code>callPackage</code>.</p>
<h2 id="callpackage"><a class="header" href="#callpackage">CallPackage</a></h2>
<p><code>callPackage</code> is a function which will call a function with the
appropriate dependencies. The package set will generally expose
a <code>callPackage</code> function with the current package set already bound.</p>
<p>A minimal callPackage implementation can be thought of as:</p>
<pre><code>  # &lt;nixpkgs&gt;/lib/customisation.nix
  # callPackageWith :: Attr Set -&gt; (Attr Set -&gt; drv) -&gt; Attr Set -&gt; drv
  callPackageWith = autoArgs: fn: args:
  # autoArgs - Attr set of &quot;defaults&quot;, for nixpkgs this would be all top-level packages
  # fn       - A nix expression which uses an attr set as in input.
  # args     - Overrides to the defaults in autoArgs
  let
    # if a file is passed, import it
    f = if lib.isFunction fn then fn else import fn;

    # find what attrs are shared from expression and package set
    # then override the values by anything passed explicitly through args
    fargs = builtins.intersectAttrs (lib.functionArgs f) autoArgs // args;
  in
    f fargs; # With nix, creation of a derivation is just function application
</code></pre>
<p>Usage of <code>callPackage</code> would look something like this:</p>
<pre><code>  # &lt;nixpkgs&gt;/pkgs/top-level/all-packages.nix
  { lib, ... }:

  let
    self = with self; {
      ...

      callPackage = lib.callPackageWith self;

      openssl = callPackage ../libraries/openssl { };
    };
  in self
</code></pre>
<p>With <code>callPackage</code> we only need to explicitly pass an attr set
if we need to override the default values that would have been
present in the package set.</p>
<p>In nixpkgs, <code>callPackage</code> has been extended to include helpful
package hints, and thus the complexity has grown, but the 
underlying intuition has remained the same.</p>
<p>In javascript, <code>callPackage</code> would be an example of a curried function,
where there's an implicit package set bound to it.</p>
<h1 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h1>
<h2 id="avoid-excessive-with-usage"><a class="header" href="#avoid-excessive-with-usage">Avoid excessive <code>with</code> usage</a></h2>
<p>Although <code>with</code> can be useful in small scopes. Doing something such as
<code>with pkgs;</code> is usually discouraged. This is most dramatic with <code>pkgs</code>,
in which you will introduce 15,000+ variables into your namespace. Although
you may be aware of what is coming from where when you first write the code,
this implicit context is much harder to re-create each time the expression
is visited in the future. This is compounded with multiple <code>with</code> expressions,
as later <code>with</code>'s will shadow previously defined values.</p>
<p>This is not to say that all usage of <code>with</code> is discouraged, it's often
encouraged with certain tasks such as defining the <code>meta</code> section of
a package; as most attributes of a meta section will be pulling from
<code>lib</code>. So a <code>meta = with lib; { ... }</code> can dramatically reduce how
many <code>lib.</code> need to be explicitly added. Also, it's very common for
NixOS modules to use <code>with lib;</code> for the whole file as many of the
module building blocks are exposed through <code>lib</code>.</p>
<p>In general, <code>with</code> should be scoped as much as possible:</p>
<pre><code class="language-nix"># good
stdenv.mkDerivation {
  ...
  buildInputs = [ openssl ]
    ++ (with xorg; [ libX11 libX11randar xinput ]);
}

# also good, just repetitive
stdenv.mkDerivation {
  ...
  buildInputs = [ openssl xorg.libX11 xorg.libX11randar xorg.xinput ];
}

# discouraged, now all of xorg is exposed everywhere
with xorg;

stdenv.mkDerivation {
  ...
  buildInputs = [ openssl libX11 libX11randar xinput ];
}
</code></pre>
<h1 id="common-mistakes"><a class="header" href="#common-mistakes">Common Mistakes</a></h1>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<p>The space after <code>:</code> is required. Without a space, nix will
parse the value as an url, and represent it as a string</p>
<pre><code>nix-repl&gt; :t x: x
a function

nix-repl&gt; :t x:x
a string
</code></pre>
<h2 id="lists-1"><a class="header" href="#lists-1">Lists</a></h2>
<p>Functions and lists use whitespace to do funcation application,
however, list element delimination takes precedence over function application.</p>
<p>For example, if someone were to try and use optional python
integration on a package, they may write something like:</p>
<pre><code class="language-nix">  extraPackages = [
    somePackage.override { withPython = true; }
  ];
</code></pre>
<p>In this example, it's an array of two elements, <code>somePackage.override</code> is a function, and the other element
is an attr set. This is more accurately represented as:</p>
<pre><code class="language-nix">  extraPackages = [
    (somePackage.override) # type: Attr -&gt; drv
    ({ withPython = true; }) # type: Attr
  ];
</code></pre>
<p>The correct usage of this would be:</p>
<pre><code class="language-nix">  extraPackages = [
    (somePackage.override { withPython = true; }) # type: drv
  ];
</code></pre>
<h1 id="building-a-nix-package"><a class="header" href="#building-a-nix-package">Building a Nix Package</a></h1>
<p>Building a package for nix can range from trivial to near impossible.
Generally the difference between the two experiences is
determined by how many assumptions the build process makes.
Toolchains which have strong integrity guarantees (e.g. lock files)
, and allow for offline builds are generally more nix compatible.</p>
<p>Nix is language and toolchain agnostic. Support for many
toolchains have been added to nixpkgs, but the nix build
environment is very constrained so many <code>&lt;toolchain&gt;2nix</code> tools have
arisen to try and bridge the gap in expectations.</p>
<h1 id="simple-c-program"><a class="header" href="#simple-c-program">Simple C program</a></h1>
<p>Many fundamental unix tools are written in C, as it provides many
benefits to system programmers. In this section we will cover
how to compile and package a simple C application to demonstrate
how the nix build process works.</p>
<h2 id="impure-build-and-install"><a class="header" href="#impure-build-and-install">Impure build and install</a></h2>
<p>Given the example C program:</p>
<pre><code>$ cat simple.c
#include &lt;stdio.h&gt;

void main() {
  printf(&quot;Hello from Nix!&quot;);
}
</code></pre>
<p>The build and installation of which on a traditional FHS
system may look like:</p>
<pre><code># build
$ gcc simple.c -o hello_nix
# install
$ sudo cp hello_nix /usr/bin/hello_nix
</code></pre>
<p>However, let's see how this would be done in nix</p>
<h2 id="nix-build"><a class="header" href="#nix-build">Nix build</a></h2>
<p>Implicit to the previous workflow, was the availability of the GNU C Compiler and
the usage of the <code>cp</code> command. In many package repositories, usage of these tools
is near universal; and forms the foundation for how to build most other software.</p>
<p>Although C compilers and GNU's <code>coreutils</code> (where <code>cp</code> comes from) have their
own specific packages in nixpkgs, generally they are aggregated into a pseudo-package
called <code>stdenv</code> in nixpkgs. The function <code>stdenv.mkDerivation</code> provides:</p>
<ul>
<li>A nixpkgs-compatible wrapped C compiler (GCC on linux, Clang on MacOS)</li>
<li>GNU coreutils</li>
<li>A default &quot;builder&quot; script</li>
</ul>
<p><code>stdenv</code> will be covered in more detail in <a href="./ch06-02-stdenv.html">the next section</a>.</p>
<p>A nixified version of the build would look like:</p>
<pre><code># simple.nix
let
  pkgs = import &lt;nixpkgs&gt; { };
in
  pkgs.stdenv.mkDerivation {
    name = &quot;hello-nix&quot;;

    src = ./.;

    # Use $CC as it allows for stdenv to reference the correct C compiler
    buildPhase = ''
      $CC simple.c -o hello_nix
    '';
  }
</code></pre>
<p>Nix defaults to a Makefile workflow unless specified otherwise.
So stdenv will default to calling <code>make install</code> for the <code>installPhase</code> which will
fail with <code>No rule to make target 'install'</code> so we need
to also fix how nix will install the package.</p>
<pre><code>$ nix-build simple.nix
this derivation will be built:
  /nix/store/dbavzdq1idb0hvwdh7r9gfn2l52kvycf-hello-nix.drv
...
install flags: SHELL=/nix/store/3j918i1nbwhby0y38bn2r438rjhh8f4d-bash-5.1-p16/bin/bash install
make: *** No rule to make target 'install'.  Stop.
error: builder for '/nix/store/dbavzdq1idb0hvwdh7r9gfn2l52kvycf-hello-nix.drv' failed with exit code 2;
</code></pre>
<h2 id="nix-install"><a class="header" href="#nix-install">Nix install</a></h2>
<p>The second glaring problem in the old workflow, is that
we had a convention as to where to install the executable in /usr/bin/.
But installing software in a central location is one the issues that
nix is trying to solve. Instead, nix needs to install files on a per-package
basis, thus where we need to install files will change for every package.
So how do we know where to install files with nix?</p>
<p>Nix will bind the values defined in the derivation to environment variables
inside of the nix build. The default &quot;output&quot; of a package is <code>out</code>, which will be bound
to the hashed nix store path mentioned in <a href="./ch04-01-create-a-derivation.html">the derivation section</a>.</p>
<p>So an adjusted workflow would be:</p>
<pre><code># build
$ gcc simple.c -o hello_nix
# install
$ mkdir -p $out/bin
$ cp hello_nix $out/bin/hello_nix
</code></pre>
<p>Extending the example above, the easiest solution would be to write our own <code>installPhase</code>. The
resulting expression would be:</p>
<pre><code># simple.nix
let
  pkgs = import &lt;nixpkgs&gt; { };
in
  pkgs.stdenv.mkDerivation {
    name = &quot;hello-nix&quot;;

    src = ./.;

    buildPhase = ''
      $CC simple.c -o hello_nix
    '';

    installPhase = ''
      mkdir -p $out/bin
      cp hello_nix  $out/bin/hello_nix
    '';
  }
</code></pre>
<p>Now when we build the package, nix is able to realize it. After which we can use the executable:</p>
<pre><code>$ nix-build simple.nix
this derivation will be built:
  /nix/store/9j274i4wckn0ksxpj7asd8vbk67kfz4p-hello-nix.drv
...
/nix/store/giwy9rwzwsdvh86pvdpv37lkwms7xcx9-hello-nix

$ ./result/bin/hello_nix
Hello from Nix!
</code></pre>
<h1 id="stdenv"><a class="header" href="#stdenv">Stdenv</a></h1>
<p><code>stdenv</code> provides a foundation for building C/C++ software with nixpkgs. It includes, but is not limited to
containing tools such as: a c compiler and related tools, GNU coreutils, GNU awk, GNU sed, findutils, strip, bash, GNUmake, bzip2, gzip,
and many more tools. Stdenv also provides a default &quot;builder.sh&quot; script which will perform the build of a package. The default builder script
is comprised of many smaller &quot;phases&quot; which package maintainers can alter slightly as needed. The goal of <code>stdenv</code> is to enable most C/C++ + <code>Makefile</code> workflows; in theory, if a software
package has these installation:</p>
<pre><code>./configure # configurePhase, optional
make # buildPhase
make install # installPhase
</code></pre>
<p>Then the only necessary changes for it to work with <code>stdenv.mkDerivation</code> would be the inclusion of
<code>installFlags = [ &quot;PREFIX=$(out)&quot; ];</code> to communicate where the package should be installed with nix.</p>
<h2 id="unique-qualities-of-nixpkgs-stdenv"><a class="header" href="#unique-qualities-of-nixpkgs-stdenv">Unique qualities of Nixpkgs' Stdenv</a></h2>
<h3 id="wrapped-c-compiler"><a class="header" href="#wrapped-c-compiler">Wrapped C Compiler</a></h3>
<p><code>stdenv</code> exposes a wrapped compiler to help communicate nix-specific to the compiler without
having to rely on the upstream maintainer to expose such allowances in configuration. For example,
let's assume that a package doesn't officially support MacOS, so all testing and building
occurs with Linux + GCC. Trying to package this for MacOS might be difficult because the logic
may call <code>gcc</code> directly, and assume</p>
<ul>
<li>Nix differences
<ul>
<li>Wrapped compiler</li>
<li>stdenv <a href="https://nixos.org/manual/nixpkgs/stable/#ssec-stdenv-functions">shell functions</a></li>
</ul>
</li>
</ul>
<h1 id="phases"><a class="header" href="#phases">Phases</a></h1>
<h1 id="build-dependencies"><a class="header" href="#build-dependencies">Build Dependencies</a></h1>
<p>How to add build dependencies for a packages</p>
<ul>
<li>Difference between nativeBuildInputs and buildInputs</li>
<li>Difference between propagated and non-propagated inputs</li>
<li>Demonstrate some common usage patterns around dependencies</li>
</ul>
<p>How do packages find dependencies when building?</p>
<ul>
<li>They don't, nix attempts to fulfill assumptions made by the toolchain
<ul>
<li>Generally delegated to tooling which specializes in dependency discovery
<ul>
<li><code>PKG_CONFIG_PATH</code>? for <code>pkg-config</code></li>
<li><code>CMAKE_MODULE_PATH</code>? for <code>cmake</code></li>
<li><code>PYTHONPATH</code> for <code>python</code> when using <code>buildPythonPackage</code></li>
<li>etc.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Explain difference between out, dev, lib, and other outputs</p>
<ul>
<li>It's a common use case to reference one or more outputs</li>
<li>Mention the lib's <code>getDev</code>, <code>getDev</code>, <code>getLib</code>, and <code>getMan</code> helpers</li>
<li>TODO: Link to another section expanding on multi-output derivations</li>
</ul>
<h1 id="runtime-dependencies"><a class="header" href="#runtime-dependencies">Runtime Dependencies</a></h1>
<ul>
<li>
<p>Explain how nix finds runtime dependencies (essentially greps for valid /nix/store/... paths)</p>
<ul>
<li>TODO: link to another section on how to reduce closure sizes</li>
<li>TODO: link to another section on how to ensure runtime dependencies are correctly picked up
<ul>
<li>E.g. jar files are compressed, but may reference another package which needs to be present on the host</li>
<li>Generally this is done by doing <code>echo ${dependency} &gt; $out/nix-support</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>How to determine a runtime depdency (e.g. <code>nix-store -q --requisites</code>)</p>
</li>
<li>
<p>How to wrap programs so that certain dependencies are present on PATH or in other ways</p>
</li>
<li>
<p>Mention that patching is sometimes required (e.g. python), as there's not always a
deterministic way to define how a package will be consumed (e.g. python module importing another)</p>
</li>
</ul>
<h1 id="building-packages-for-other-toolchains"><a class="header" href="#building-packages-for-other-toolchains">Building Packages for Other Toolchains</a></h1>
<ul>
<li>Introduce the concept of shellhooks</li>
<li>Provide links to documentation for:
<ul>
<li>Cmake</li>
<li>Meson</li>
<li>Bazel</li>
</ul>
</li>
</ul>
<h1 id="building-nix-packages-for-non-c-programming-languages"><a class="header" href="#building-nix-packages-for-non-c-programming-languages">Building Nix packages for non-C programming languages</a></h1>
<ul>
<li>
<p>Almost all support for other programming languages are built
upon stdenv.mkDerivation</p>
</li>
<li>
<p>Provide links to official documentation on a given programming language</p>
</li>
</ul>
<h1 id="patching-packages"><a class="header" href="#patching-packages">Patching Packages</a></h1>
<ul>
<li>
<p>Common scenario where a pull request hasn't been merged or a new release hasn't
been cut, but a change should be applied to a given package.</p>
</li>
<li>
<p>Cover <code>patches</code> attr for mkDerivation</p>
</li>
<li>
<p>Introduce <code>fetchpatch</code> utility</p>
<ul>
<li>Show example</li>
<li>Make note that fetchpatch does it's own sanitization, meaning that fetchpatch
and <code>nix-prefetch-url</code> will generally create different FODs</li>
<li>Make note that generally a comment should be added to explain why a patch is being
added, and when is it an appropriate time to remove it</li>
</ul>
</li>
</ul>
<h1 id="multiple-outputs"><a class="header" href="#multiple-outputs">Multiple Outputs</a></h1>
<ul>
<li>Why multiple outputs
<ul>
<li>Closure size</li>
<li>Cross Compilation</li>
</ul>
</li>
<li>How to Leverage</li>
<li>Any footguns
<ul>
<li><code>placeholder</code></li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
