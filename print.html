<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nix-Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="ch00-00-the-nix-package-manager.html">The Nix Package Manager</a></li><li class="chapter-item expanded affix "><a href="ch01-00-forward.html">Forward</a></li><li class="chapter-item expanded affix "><a href="ch02-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch03-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-derivations.html"><strong aria-hidden="true">2.</strong> Derivations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-create-a-derivation.html"><strong aria-hidden="true">2.1.</strong> Create a Derivation</a></li><li class="chapter-item expanded "><a href="ch04-02-realise-a-derivation.html"><strong aria-hidden="true">2.2.</strong> Realise a Derivation</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-the-nix-language.html"><strong aria-hidden="true">3.</strong> The Nix Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-language-basics.html"><strong aria-hidden="true">3.1.</strong> Language Basics</a></li><li class="chapter-item expanded "><a href="ch05-02-functions.html"><strong aria-hidden="true">3.2.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch05-03-imports-and-callpackage.html"><strong aria-hidden="true">3.3.</strong> Imports and callPackage</a></li><li class="chapter-item expanded "><a href="ch05-04-best-practices.html"><strong aria-hidden="true">3.4.</strong> Best Practices</a></li><li class="chapter-item expanded "><a href="ch05-05-common-mistakes.html"><strong aria-hidden="true">3.5.</strong> Common Mistakes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-building-a-nix-package.html"><strong aria-hidden="true">4.</strong> Building a Nix Package</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-simple-c-program.html"><strong aria-hidden="true">4.1.</strong> Simple C program</a></li><li class="chapter-item expanded "><a href="ch06-02-stdenv.html"><strong aria-hidden="true">4.2.</strong> Stdenv</a></li><li class="chapter-item expanded "><a href="ch06-03-phases.html"><strong aria-hidden="true">4.3.</strong> Phases</a></li><li class="chapter-item expanded "><a href="ch06-04-build-dependencies.html"><strong aria-hidden="true">4.4.</strong> Build Dependencies</a></li><li class="chapter-item expanded "><a href="ch06-05-runtime-dependencies.html"><strong aria-hidden="true">4.5.</strong> Runtime Dependencies</a></li><li class="chapter-item expanded "><a href="ch06-06-building-packages-for-other-toolchains.html"><strong aria-hidden="true">4.6.</strong> Building Packages for Other Toolchains</a></li><li class="chapter-item expanded "><a href="ch06-07-building-packages-for-other-languages.html"><strong aria-hidden="true">4.7.</strong> Building Packages for Other Languages</a></li><li class="chapter-item expanded "><a href="ch06-08-patching.html"><strong aria-hidden="true">4.8.</strong> Patching</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Nix-Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-nix-package-manager"><a class="header" href="#the-nix-package-manager">The Nix Package Manager</a></h1>
<p><em>Quickly Explain nix package manager</em></p>
<p><em>Explain nix ecosystem</em></p>
<ul>
<li>nix (the language)</li>
<li>nix (the package manager)</li>
<li>nixpkgs (the package repository)</li>
<li>NixOS (the Operating System)</li>
</ul>
<h1 id="foreward"><a class="header" href="#foreward">Foreward</a></h1>
<p><em>Explain the intent and goals of nix.</em></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><em>State intent of the nix-book</em></p>
<p><em>Who is this for? And what's their benefit</em></p>
<ul>
<li>Developers</li>
<li>Devops</li>
<li>Package maintainers</li>
<li>Companies</li>
</ul>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p><em>Something similar to the beginning of https://nixos.org/guides/nix-pills/install-on-your-running-system.html#idm140737320805808</em></p>
<h1 id="derivations"><a class="header" href="#derivations">Derivations</a></h1>
<p>Derivations are the defining feature of nix. Derivations attempt to capture everything
that it would take to build a packages. The cummilation of all build depdencies
is commonly refered to as the package's &quot;build closure&quot;. More dependencies that a
package refers to, more package will need to be created in order to attempt a
build. Generally, dependencies of a derivation are other derivations.</p>
<h2 id="types-of-derivations"><a class="header" href="#types-of-derivations">Types of Derivations</a></h2>
<h3 id="evaluated-derivations"><a class="header" href="#evaluated-derivations">Evaluated Derivations</a></h3>
<p>These are generally what are referred to when the term derivation is used. These
derivations are defined about all of the dependencies, build phases, and flags
present during a build. When a store path has a hash, this is what the hash
is capturing.</p>
<h3 id="fixed-output-derivations-fods"><a class="header" href="#fixed-output-derivations-fods">Fixed Output Derivations (FODs)</a></h3>
<p>These are the &quot;leaves&quot; of any build closure, in that, they do not refer to other
derivations. These derivations are defined by
their content. These derivations are easily differientiated because they
will contain a sha256 (or other hash) which is used to enforce that an artifact
is reproducible.</p>
<p>One critical difference from evaluated derivations is that Fixed-Output derivations
are able to have access to the network while fetching contents. This &quot;impurity&quot;
is offset by enforcing that the hash matches, and reproducibility is delegated to
the process which fetchs the assets.</p>
<h3 id="content-addressable-derivations-ca-derivations"><a class="header" href="#content-addressable-derivations-ca-derivations">Content-Addressable Derivations (CA Derivations)</a></h3>
<p><strong>NOTE:</strong> This derivation type is still in an experimental state. And care should be given
to enabling content-addressable derivation on a machine.</p>
<p>TODO: Add section on CA derivations</p>
<h1 id="create-a-derivation"><a class="header" href="#create-a-derivation">Create a Derivation</a></h1>
<p>Before a package is built, a derivation must be created. This process of creating a derivation
is called instantiatiation&quot;, or sometimes also refered to as evaluation. Every package in
nixpkgs has a corresponding derivation. This means that we can
create and inspect the derivation for anything exposed in nixpkgs. An example
would be:</p>
<pre><code>$ nix-instantiate '&lt;nixpkgs&gt;' -A hello
/nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv

# or using flakes, nix&gt;=2.4

$ nix eval nixpkgs#hello.drvPath
&quot;/nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv&quot;
</code></pre>
<p>To inspect the contents of the drv, one can use the <code>nix show-derivation</code> utility.</p>
<pre><code>$ nix show-derivation /nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv
{
  &quot;/nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv&quot;: {
    &quot;outputs&quot;: {
      &quot;out&quot;: {
        &quot;path&quot;: &quot;/nix/store/f4bywv8hjwl0ckv7l077pnap81h6qxw4-hello-2.10&quot;
      }
...
</code></pre>
<p>There's a few important features of a derivation:</p>
<ul>
<li>It's a description of how to build the package from source</li>
<li>The output paths are determined before the build begins</li>
<li>All dependencies are known, and have a similar derivation description of their builds</li>
<li>Any additional flags (makeFlags, configuration flags, cflags, or ld flags) are explicitly stated</li>
<li>There's no ambiguity. The system, architecture, and other options have been resolved.</li>
<li>It's immutable. If you want to change a derivation, you need to evaluate a new one.</li>
<li>It's unique. The hashing scheme ensures that there should only ever be one derivation; if two derivations match, then they are exactly the same in every way.</li>
</ul>
<h1 id="realise-a-derivation"><a class="header" href="#realise-a-derivation">Realise a derivation</a></h1>
<p>Building a derivation is referred to as &quot;realisation&quot;. A derivation is just an abstract
description of a package, based upon what it requires to build. However, a derivation does
not produce any expected outputs until it has been realised into something tangible. Taking
the example from above, one can build a derivations like so:</p>
<pre><code>$ nix-store --realise /nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv
...
/nix/store/f4bywv8hjwl0ckv7l077pnap81h6qxw4-hello-2.10

# or in nix flakes:

$ nix build nixpkgs#hello
...
/nix/store/f4bywv8hjwl0ckv7l077pnap81h6qxw4-hello-2.10
</code></pre>
<p>The <code>nix-build</code> and <code>nix build</code> commands will perform both instantiation and realisation. 
These are the most commands used when iterating on packages. One could also do:</p>
<pre><code>$ nix-buid '&lt;nixpkgs&gt;' -A hello
# these are the same, nix build is just much more concise
$ nix-store --realise $(nix-instantiate '&lt;nixpkgs&gt;' -A hello)
</code></pre>
<p><em>Note:</em> Many other commands also will realise a derivation
as part of a workflow. Some examples are:
<code>nix-shell</code>, <code>nix shell</code>, <code>nix-env</code>, <code>nix run</code>, and <code>nix profile</code>.
These commands are very goal oriented and will differ
significantly in how they leverage nix, often realisation
is an side-effect to achieve that goal.</p>
<h1 id="the-nix-language"><a class="header" href="#the-nix-language">The Nix Language</a></h1>
<p>Nix is a pure, lazy, functional language which serves a domain-specific language (DSL)
for writing nix derivations and expressions. In general, nix can be thought of as 
JSON with functions. </p>
<p><em>Concise version of https://nixos.org/guides/nix-pills/basics-of-language.html</em></p>
<h1 id="nix-language-basics"><a class="header" href="#nix-language-basics">Nix Language Basics</a></h1>
<h2 id="primitive-values"><a class="header" href="#primitive-values">Primitive Values</a></h2>
<p>These mostly similar to JSON:</p>
<table><thead><tr><th>Type</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td>integer</td><td>Whole number</td><td>1</td></tr>
<tr><td>float</td><td>Floating point number</td><td>1.054</td></tr>
<tr><td>string</td><td>UTF-8 string</td><td>&quot;hello!&quot;</td></tr>
<tr><td>path</td><td>File or url</td><td>./default.nix</td></tr>
</tbody></table>
<p><em>NOTE</em>: Paths are special. They will be resolved relative to the file.
They must start with a &quot;.&quot; or &quot;/&quot;, similar to how they would be expressed in a shell.
If a path is referenced as part of a package, that path will be added to the
nix store, and all references to that path will be substituted with the nix store path.</p>
<p><em>NOTE</em>: If a path to a directory is passed, but a file was expected; then nix will look
for a <code>default.nix</code> located in that directory, and will target that.</p>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>Nix exposes two ways to express strings. Strings are enclosed with double quotes: <code>&quot;hello&quot;</code>.
This works well for small strings, such as simple flags. However, it's common to write a
block of commands which need to be executed; for this, nix also has multi-line support with
the &quot;lines&quot; construct. &quot;lines&quot; are denoted by two single quotes.</p>
<p>Example usage of lines:</p>
<pre><code>  postPatch = ''
    ./autogen.sh
    mkdir build
    cd build
  '';
</code></pre>
<p>Here, we have postPatch being assigned a series of commands to be ran as part of a build.</p>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<p>Lists work similarly to most other languages, but are whitespace delimited. <code>[ 1 2 ]</code> is an
array with elements <code>1</code> and <code>2</code>.</p>
<p><strong>Note</strong>: For oddities around lists and elements which use whitespace, please see <a href="./ch05-05-common-mistakes.html#lists">list common mistakes</a>.</p>
<h2 id="attribute-set-attr-set"><a class="header" href="#attribute-set-attr-set">Attribute Set (Attr set)</a></h2>
<p>This can be thought of as a dictionary or map in most other languages. The important distinct is that the
keys are always ordered, so that the order doesn't influence how a derivation will produce a hash. Attr sets
values do not need to be of the same type. Attr sets are constructed using an <code>=</code> sign which denotes key value
pairs which are separated with semicolons <code>;</code>, the attr set is enclosed with curly braces <code>{ }</code>.</p>
<pre><code>{ foo = &quot;bar&quot;; count = 5; flags = ''-g -O3''; }
</code></pre>
<p>You will commonly see empty att sets, and example being:</p>
<pre><code>  hello = callPackage ../applications/misc/hello { };
</code></pre>
<h2 id="if--else-logic"><a class="header" href="#if--else-logic">If / Else logic</a></h2>
<p>Like many other functional programming languages, you cannot
use <code>if</code> without an accompanying <code>else</code> clause. This is because
the expression needs to return a value, not just follow a code
path.</p>
<pre><code>  extension = if stdenv.isDarwin then
      &quot;.dylib&quot;
    else
      &quot;.so&quot;;
</code></pre>
<p><strong>Note</strong>: The proper way to find the shared library extension
within nixpkgs is <code>hostPlatform.extensions.sharedLibrary</code>.</p>
<h2 id="let-expressions"><a class="header" href="#let-expressions">Let expressions</a></h2>
<p>Let expressions are a way to define values to be used later in a given 'in' scope.
Generally these are used to alter a given value to conform to a
slightly different format. Let expressions can refer
to other values defined in the same let scope. For haskell users,
let expressions work similarly to how they work in Haskell.</p>
<pre><code>  src = let
    # e.g. 3.1-2 -&gt; 3_1_2
    srcVersion = lib.strings.replaceStrings [ &quot;.&quot; &quot;-&quot; ] [ &quot;_&quot; &quot;_&quot;] version;
    srcUrl = &quot;https://example.com/download/${pname}-${srcVersion}.tar.gz&quot;;
  in fetchurl {
    url = srcUrl;
    sha256 = &quot;...&quot;;
  };
</code></pre>
<h2 id="with-expressions"><a class="header" href="#with-expressions">With expressions</a></h2>
<p>With expressions allows for many values on an attr set to be
exposed by their key names.</p>
<pre><code>  # before
  meta = {
    licenses = lib.licenses.cc0;
    maintainers = [ lib.maintainers.jane lib.maintainers.joe ];
    platforms = lib.platforms.unix;
  };
</code></pre>
<pre><code>  # after
  meta = with lib; {
    licenses = licenses.cc0;
    maintainers = with maintainers; [ jane joe ];
    platforms = platforms.unix;
  };
</code></pre>
<h2 id="laziness"><a class="header" href="#laziness">Laziness</a></h2>
<p>Many pure functional programming languages also have the feature that the
evaluation model of the language is lazy. This means that the values
of a data structure aren't computed until needed, they are lazily computed.
The benefits for nix is that evaluating a package doesn't mean computing
all packages, but only computing the dependency graph for the packages
requested. In practice this means limiting the scope of an action from
80,000+ possible dependencies to just the dependencies explicitly mentioned
by the nix expressions.</p>
<p>Although laziness isn't a hard requirement for nix to work. The purity
model of nix makes laziness more of symptom than an explicit design goal.
However, It does enable many implicit benefits such as <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>.</p>
<h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Nix only has unary functions: unary functions are functions which
only accept one parameter. However, in combination with
<a href="https://en.wikipedia.org/wiki/currying">uncurrying</a>, you can
create functions which take an arbitrary number of parameters.</p>
<p>Functions can be treated as values, and freely passed to other
functions as such. To name a function, it just needs to be assigned
to variable, much as you would do to a literal.</p>
<p>Function examples:</p>
<pre><code># creation, and immediate application of a nameless function
nix-repl&gt; (x: x + 2) 3
5

# assigning a function to a variable, then later applying it
nix-repl&gt; addTwo = x: x + 2

nix-repl&gt; addTwo 3
5

# two parameters
nix-repl&gt; sumBoth = x: y: x + y

nix-repl&gt; sumBoth 2 5
7
</code></pre>
<h2 id="attr-sets-as-inputs"><a class="header" href="#attr-sets-as-inputs">Attr sets as inputs</a></h2>
<p>Nix also heavily uses attr sets to pass around many arguments.
In nixpkgs, this is most commonly used to express what subset of
packages and utilities should be used for a nix expression. It's
also useful when a large context for a function is needed, and
an ordered list of parameters is a poor fit.</p>
<p>Attr sets as inputs are also particular good when the function
can provide good defaults, and only a small subset of inputs are
expected to be edited.</p>
<p>Function examples:</p>
<pre><code class="language-nix"># function which takes an attr set
nix-repl&gt; addTwo = { x }: x + 2

nix-repl&gt; addTwo { x = 3; }
5

# function which takes optional attr set values
nix-repl&gt; addTwoOptional = { x ? 4 }: x + 2

nix-repl&gt; addTwoOptional { }
6

nix-repl&gt; addTwoOptional { x = 5; }
7

# same as above, but binding the entire attr set to another variable
nix-repl&gt; addTwoOptional = { x ? 4 }@args: args.x + 2

nix-repl&gt; addTwoOptional  { x = 6; }
8
</code></pre>
<p><strong>Note</strong>: The <code>@</code> syntax is not very common for most nix expressions.
Its most common use case are &quot;helpers&quot;, which only care about a
subset of arguments, and will then call another function with some
of the inputs pruned. A good example of this is the <code>pkgs.fetchFromGithub</code>
fetcher; which will know how to translate owner, repo, rev, and
other options into a call to <code>builtsin.fetchzip</code> or <code>builtins.fetchgit</code>.</p>
<h1 id="imports-and-callpackage"><a class="header" href="#imports-and-callpackage">Imports and callPackage</a></h1>
<ul>
<li>trivial import example</li>
<li>example of import json data</li>
<li>example of creating a derivation with imports</li>
<li>example of creating the same derivation, but with callPackage</li>
</ul>
<h1 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h1>
<p>TODO: add what are things people should do.</p>
<h2 id="avoid-excessive-with-usage"><a class="header" href="#avoid-excessive-with-usage">Avoid excessive <code>with</code> usage</a></h2>
<p>Although <code>with</code> can be useful in small scopes. Doing something such as
<code>with pkgs;</code> is usually discouraged. This is most dramatic with <code>pkgs</code>,
in which you will introduce 15,000+ variables into your namespace. Although
you may be aware of what is coming from where when you first write the code,
this implicit context is much harder to re-create each time the expression
is visited in the future. This is compounded with multiple <code>with</code> expressions,
as later <code>with</code>'s will shadow previously defined values.</p>
<p>This is not to say that all usage of <code>with</code> is discouraged, it's often
encouraged with certain tasks such as defining the <code>meta</code> section of
a package; as most attributes of a meta section will be pulling from
<code>lib</code>. So a <code>meta = with lib; { ... }</code> can dramatically reduce how
many <code>lib.</code> need to be explicitly added. Also, it's very common for
NixOS modules to use <code>with lib;</code> for the whole file as many of the
module building blocks are exposed through <code>lib</code>.</p>
<p>In general, <code>with</code> should be scoped as much as possible:</p>
<pre><code class="language-nix"># good
stdenv.mkDerivation {
  ...
  buildInputs = [ openssl ]
    ++ (with xorg; [ libX11 libX11randar xinput ]);
}

# also good, just repetitive
stdenv.mkDerivation {
  ...
  buildInputs = [ openssl xorg.libX11 xorg.libX11randar xorg.xinput ];
}

# discouraged, now all of xorg is exposed everywhere
with xorg;

stdenv.mkDerivation {
  ...
  buildInputs = [ openssl libX11 libX11randar xinput ];
}
</code></pre>
<h1 id="common-mistakes"><a class="header" href="#common-mistakes">Common Mistakes</a></h1>
<h2 id="lists-1"><a class="header" href="#lists-1">Lists</a></h2>
<p>Functions and lists use whitespace to do funcation application,
however, list element delimination takes precedence over function application.</p>
<p>For example, if someone were to try and use optional python
integration on a package, they may write something like:</p>
<pre><code class="language-nix">  extraPackages = [
    somePackage.override { withPython = true; }
  ];
</code></pre>
<p>In this example, it's an array of two elements, <code>somePackage.override</code> is a function, and the other element
is an attr set. This is more accurately represented as:</p>
<pre><code class="language-nix">  extraPackages = [
    (somePackage.override) # type: Attr -&gt; drv
    ({ withPython = true; }) # type: Attr
  ];
</code></pre>
<p>The correct usage of this would be:</p>
<pre><code class="language-nix">  extraPackages = [
    (somePackage.override { withPython = true; }) # type: drv
  ];
</code></pre>
<h1 id="building-a-nix-package"><a class="header" href="#building-a-nix-package">Building a Nix Package</a></h1>
<p><em>Derivations were already introduced, expand on what a &quot;package&quot; is, how to build one using the cli</em></p>
<h1 id="simple-c-program"><a class="header" href="#simple-c-program">Simple C program</a></h1>
<h1 id="stdenv"><a class="header" href="#stdenv">Stdenv</a></h1>
<p><em>Introduce stdenv</em></p>
<ul>
<li>Includes c toolchain (gcc + binutils on linux), coreutils, gawk, sed, findutils, strip, bash, make, bzip2, gzip</li>
<li>Nix differences
<ul>
<li>Wrapped compiler</li>
<li>stdenv <a href="https://nixos.org/manual/nixpkgs/stable/#ssec-stdenv-functions">shell functions</a></li>
</ul>
</li>
</ul>
<h1 id="phases"><a class="header" href="#phases">Phases</a></h1>
<h1 id="build-dependencies"><a class="header" href="#build-dependencies">Build Dependencies</a></h1>
<p>How to add build dependencies for a packages</p>
<ul>
<li>Difference between nativeBuildInputs and buildInputs</li>
<li>Difference between propagated and non-propagated inputs</li>
<li>Demonstrate some common usage patterns around dependencies</li>
</ul>
<p>How do packages find dependencies when building?</p>
<ul>
<li>They don't, nix attempts to fulfill assumptions made by the toolchain
<ul>
<li>Generally delegated to tooling which specializes in dependency discovery
<ul>
<li><code>PKG_CONFIG_PATH</code>? for <code>pkg-config</code></li>
<li><code>CMAKE_MODULE_PATH</code>? for <code>cmake</code></li>
<li><code>PYTHONPATH</code> for <code>python</code> when using <code>buildPythonPackage</code></li>
<li>etc.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Explain difference between out, dev, lib, and other outputs</p>
<ul>
<li>It's a common use case to reference one or more outputs</li>
<li>Mention the lib's <code>getDev</code>, <code>getDev</code>, <code>getLib</code>, and <code>getMan</code> helpers</li>
<li>TODO: Link to another section expanding on multi-output derivations</li>
</ul>
<h1 id="runtime-dependencies"><a class="header" href="#runtime-dependencies">Runtime Dependencies</a></h1>
<ul>
<li>
<p>Explain how nix finds runtime dependencies (essentially greps for valid /nix/store/... paths)</p>
<ul>
<li>TODO: link to another section on how to reduce closure sizes</li>
<li>TODO: link to another section on how to ensure runtime dependencies are correctly picked up
<ul>
<li>E.g. jar files are compressed, but may reference another package which needs to be present on the host</li>
<li>Generally this is done by doing <code>echo ${dependency} &gt; $out/nix-support</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>How to determine a runtime depdency (e.g. <code>nix-store -q --requisites</code>)</p>
</li>
<li>
<p>How to wrap programs so that certain dependencies are present on PATH or in other ways</p>
</li>
<li>
<p>Mention that patching is sometimes required (e.g. python), as there's not always a
deterministic way to define how a package will be consumed (e.g. python module importing another)</p>
</li>
</ul>
<h1 id="building-packages-for-other-toolchains"><a class="header" href="#building-packages-for-other-toolchains">Building Packages for Other Toolchains</a></h1>
<ul>
<li>Introduce the concept of shellhooks</li>
<li>Provide links to documentation for:
<ul>
<li>Cmake</li>
<li>Meson</li>
<li>Bazel</li>
</ul>
</li>
</ul>
<h1 id="building-nix-packages-for-non-c-programming-languages"><a class="header" href="#building-nix-packages-for-non-c-programming-languages">Building Nix packages for non-C programming languages</a></h1>
<ul>
<li>
<p>Almost all support for other programming languages are built
upon stdenv.mkDerivation</p>
</li>
<li>
<p>Provide links to official documentation on a given programming language</p>
</li>
</ul>
<h1 id="patching-packages"><a class="header" href="#patching-packages">Patching Packages</a></h1>
<ul>
<li>
<p>Common scenario where a pull request hasn't been merged or a new release hasn't
been cut, but a change should be applied to a given package.</p>
</li>
<li>
<p>Cover <code>patches</code> attr for mkDerivation</p>
</li>
<li>
<p>Introduce <code>fetchpatch</code> utility</p>
<ul>
<li>Show example</li>
<li>Make note that fetchpatch does it's own sanitization, meaning that fetchpatch
and <code>nix-prefetch-url</code> will generally create different FODs</li>
<li>Make note that generally a comment should be added to explain why a patch is being
added, and when is it an appropriate time to remove it</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
